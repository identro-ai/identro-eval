/**
 * Test Orchestration Types
 *
 * Core types for the centralized test orchestration system
 */
/**
 * Multi-run configuration for tests that need multiple executions
 */
export interface MultiRunConfig {
    /** Number of times to run this test */
    runCount: number;
    /** Type of runs - identical inputs or variations */
    runType: 'identical' | 'variations';
    /** Strategy for aggregating results */
    aggregationStrategy: 'compare' | 'statistical' | 'sequential';
    /** Input variations for 'variations' type */
    inputVariations?: any[];
    /** Whether to run variations in parallel or sequential */
    executionMode?: 'parallel' | 'sequential';
}
/**
 * Test specification that defines a single test to be executed
 */
export interface TestSpec {
    /** Unique identifier for this test */
    id: string;
    /** Dimension that generated this test - now supports any registered dimension */
    dimension: string;
    /** Input to be provided to the agent */
    input: any;
    /** Expected output or behavior (for LLM evaluation) */
    expected?: any;
    /** UI-friendly test description (5-7 words) */
    ui_description?: string;
    /** Evaluation criteria for LLM evaluation (DEPRECATED - use evaluation_criteria) */
    evaluationCriteria?: string[];
    /** NEW: Structured evaluation criteria with optional overrides */
    evaluation_criteria?: Array<{
        criterion: string;
        evaluation_strictness?: number;
        special_instructions?: string;
    }>;
    /** Multi-run configuration */
    multiRun?: MultiRunConfig;
    /** Agent information */
    agent: {
        id: string;
        name: string;
        framework: string;
    };
    /** Test metadata */
    metadata: {
        /** Iteration number (for consistency dimension) */
        iteration?: number;
        /** Test type (for safety dimension) */
        testType?: string;
        /** Run number (for repeated tests) */
        runNumber?: number;
        /** Total runs expected */
        totalRuns?: number;
        /** Test name from LLM generation */
        testName?: string;
        /** Rationale for this test */
        rationale?: string;
        /** Test category */
        category?: string;
        /** Expected behavior description */
        expectedBehavior?: any;
        /** Generated by LLM flag */
        generatedBy?: string;
        /** Any additional metadata */
        [key: string]: any;
    };
    /** Flow-specific synthetic inputs for HITL and external interactions */
    syntheticInputs?: Record<string, {
        action?: 'approve' | 'reject' | 'continue' | 'cancel';
        value?: any;
        reason?: string;
        data?: any;
    }>;
    /** Flow execution metadata */
    flowMetadata?: {
        isFlowTest?: boolean;
        flowName?: string;
        estimatedDuration?: number;
        captureArtifacts?: boolean;
        artifactDirectory?: string;
        dryRunIntegrations?: boolean;
        requiresHumanInput?: boolean;
        externalServices?: string[];
    };
    /** Priority for scheduling (1-5, 3 = default) */
    priority: number;
    /** Timeout for this specific test */
    timeoutMs?: number;
}
/**
 * Result from a single test run
 */
export interface SingleRunResult {
    /** Run number (1-based) */
    runNumber: number;
    /** Input used for this run */
    input: any;
    /** Output received */
    output: any;
    /** Execution latency */
    latencyMs: number;
    /** Success status */
    success: boolean;
    /** Error if failed */
    error?: string;
    /** Timestamp */
    timestamp: Date;
}
/**
 * Accumulated results from multiple runs
 */
export interface MultiRunResult {
    /** Test ID */
    testId: string;
    /** Dimension */
    dimension: string;
    /** All run results */
    runs: SingleRunResult[];
    /** Aggregated metrics */
    metrics: {
        totalRuns: number;
        successfulRuns: number;
        failedRuns: number;
        averageLatencyMs: number;
        minLatencyMs: number;
        maxLatencyMs: number;
        latencyStdDev: number;
    };
    /** Input variations used (if applicable) */
    inputVariations?: any[];
    /** Multi-run configuration used */
    multiRunConfig: MultiRunConfig;
}
/**
 * LLM evaluation result
 */
export interface LLMEvaluationResult {
    /** Raw LLM response */
    rawResponse: string;
    /** Processed score (0-1) */
    score: number;
    /** Pass/fail decision */
    passed: boolean;
    /** LLM reasoning */
    reasoning: string;
    /** LLM confidence (0-1) */
    confidence: number;
    /** Issues found by LLM */
    issues: Array<{
        type: 'error' | 'warning' | 'info';
        message: string;
        severity: number;
    }>;
    /** Token usage for cost tracking */
    tokenUsage?: number;
    /** Multi-run specific evaluation (if applicable) */
    multiRunEvaluation?: {
        /** Consistency score across runs */
        consistencyScore?: number;
        /** Variance analysis */
        varianceAnalysis?: string;
        /** Semantic similarity scores between runs */
        similarityScores?: number[];
        /** Key differences identified */
        keyDifferences?: string[];
    };
}
/**
 * Test result from executing a test spec
 */
export interface TestResult {
    /** Test spec ID */
    testId: string;
    /** Dimension that generated this test */
    dimension: string;
    /** Input provided */
    input: any;
    /** Output received (for single run) */
    output: any;
    /** Multi-run results (if applicable) */
    multiRunResult?: MultiRunResult;
    /** Execution latency in milliseconds */
    latencyMs: number;
    /** Whether the test succeeded */
    success: boolean;
    /** Error message if failed */
    error?: string;
    /** Timestamp of execution */
    timestamp: Date;
    /** LLM evaluation result (if LLM evaluation was performed) */
    llmEvaluation?: LLMEvaluationResult;
    /** Additional result metadata */
    metadata?: Record<string, any>;
}
/**
 * Dimension generator interface - dimensions generate test specs instead of executing them
 */
export interface DimensionGenerator {
    /** Dimension name */
    name: string;
    /** Human-readable description of what this dimension tests */
    description: string;
    /** Short description for UI display */
    shortDescription: string;
    /** Generate test specifications for this dimension */
    generateTests(agent: any, inputs: any[], options: any): TestSpec[] | Promise<TestSpec[]>;
    /** Interpret results from executed tests */
    interpretResults(results: TestResult[]): any;
}
/**
 * Test runner function type
 */
export type TestRunner = (input: any, metadata?: any) => Promise<{
    output: any;
    latencyMs: number;
    success: boolean;
    error?: string;
}>;
/**
 * Orchestrator configuration
 */
export interface OrchestratorConfig {
    /** Maximum concurrent test executions */
    maxConcurrency: number;
    /** Per-dimension concurrency limits */
    dimensionConcurrency?: Map<string, number>;
    /** Execution order strategy */
    executionOrder?: 'parallel' | 'sequential' | 'priority';
    /** Dimension execution priority (if executionOrder is 'priority') */
    priorityOrder?: string[];
    /** Multi-run configuration defaults */
    multiRun?: {
        /** Default run count for dimensions that support it */
        defaultRunCount?: number;
        /** Dimension-specific run counts */
        dimensionRunCounts?: {
            consistency?: number;
            safety?: number;
            performance?: number;
            schema?: number;
        };
        /** Enable multi-run for specific dimensions */
        enabledDimensions?: string[];
    };
    /** Logging configuration */
    logging?: {
        level: 'verbose' | 'normal' | 'quiet';
        maxVisibleLogs: number;
        persistLogs: boolean;
        logFile?: string;
    };
    /** Timeout configuration */
    timeouts?: {
        globalTimeoutMs: number;
        testTimeoutMs: number;
    };
    /** Retry configuration */
    retry?: {
        enabled: boolean;
        maxRetries: number;
        retryDelayMs: number;
    };
    /** Progress callback */
    onProgress?: (progress: OrchestratorProgress) => void;
    /** Log callback */
    onLog?: (entry: LogEntry) => void;
    /** Test lifecycle callbacks for external state management */
    onTestCreated?: (spec: TestSpec) => void;
    onTestStarted?: (testId: string, startTime: Date) => void;
    onTestEvaluating?: (testId: string, evaluationStartTime: Date) => void;
    onTestCompleted?: (testId: string, result: TestResult) => void;
    onTestFailed?: (testId: string, error: string) => void;
}
/**
 * Orchestrator progress information
 */
export interface OrchestratorProgress {
    /** Total tests to execute */
    totalTests: number;
    /** Tests completed */
    completedTests: number;
    /** Tests currently running */
    runningTests: number;
    /** Tests waiting in queue */
    queuedTests: number;
    /** Tests that failed */
    failedTests: number;
    /** Progress by dimension */
    dimensionProgress: Map<string, {
        total: number;
        completed: number;
        failed: number;
    }>;
    /** Currently executing tests */
    activeTests: Array<{
        testId: string;
        dimension: string;
        input: string;
        startTime: Date;
        currentRun?: number;
        totalRuns?: number;
    }>;
}
/**
 * Log entry for centralized logging
 */
export interface LogEntry {
    /** Timestamp */
    timestamp: Date;
    /** Log level */
    level: 'debug' | 'info' | 'warn' | 'error';
    /** Test ID if applicable */
    testId?: string;
    /** Dimension if applicable */
    dimension?: string;
    /** Log message */
    message: string;
    /** Additional data */
    data?: any;
}
/**
 * Test execution state
 */
export declare enum TestState {
    QUEUED = "queued",
    RUNNING = "running",
    COMPLETED = "completed",
    FAILED = "failed",
    RETRYING = "retrying",
    TIMEOUT = "timeout",
    CANCELLED = "cancelled"
}
/**
 * Test execution record
 */
export interface TestExecution {
    /** Test specification */
    spec: TestSpec;
    /** Current state */
    state: TestState;
    /** Result if completed */
    result?: TestResult;
    /** Start time */
    startTime?: Date;
    /** End time */
    endTime?: Date;
    /** Retry count */
    retryCount: number;
    /** Promise for async execution */
    promise?: Promise<TestResult>;
}
//# sourceMappingURL=types.d.ts.map